<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CObject: Class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CObject
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Class.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Class</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCClass.html">CClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">First variables in every object's memory allocation.  <a href="structCClass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCObject.html">CObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class.  <a href="structCObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCInterface.html">CInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base interface.  <a href="structCInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac27bc775549c02d69a5854ee4ba24408"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Class.html#gac27bc775549c02d69a5854ee4ba24408">CObjectCast_</a> (void *super_reference, const char *file_name, int line_num)</td></tr>
<tr class="separator:gac27bc775549c02d69a5854ee4ba24408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d2f9a8bea102eb91429b593a1664b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Class.html#ga61d2f9a8bea102eb91429b593a1664b4">CVTable</a> (void *self, const void *vtable)</td></tr>
<tr class="separator:ga61d2f9a8bea102eb91429b593a1664b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65013e78476758959625cda6ac920a5b"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Class.html#ga65013e78476758959625cda6ac920a5b">CGetVTable</a> (void *self_)</td></tr>
<tr class="separator:ga65013e78476758959625cda6ac920a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21cca1ebf690665c9c95474b0873b119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Class.html#ga21cca1ebf690665c9c95474b0873b119">CInterface::CInterface</a> (void *self, void *iface, const void *vtable)</td></tr>
<tr class="separator:ga21cca1ebf690665c9c95474b0873b119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Methods used by all classes to implement object oriented back bone. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga65013e78476758959625cda6ac920a5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* CGetVTable </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>self_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to get a pointer to the objects vtable. When calling a virtual method, this should always be used over _VTable_Key( ). For example, say we have a class inheritance chain like such: struct Square :: struct Point :: struct <a class="el" href="structCObject.html" title="Base class. ">CObject</a> Due to polymorphism, having a reference to an object of type struct Point does not guarentee that objects virtual table is given by Point_VTable_Key( ). We might have an instance of struct Square, and the correct virtual table is Square_VTable_Key( ). There is no way of knowing. Using this method guarentees we will get a pointer to the correct virtual table.</p>
<p>This method should only be used in a wrapper function for calling virtual methods. For example, say struct Point has a method struct Point::move. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void Point_Move( struct Point* self )</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    ((struct Point_VTable*) CGetVTAble(self))-&gt;move(self);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --><p>Then, application code simply calls Point_Move, which has the more cumbersome code for actually finding and calling the virtual method.</p>
<p>This method works on references to objects and interfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self_</td><td>A pointer to the object whos virtual table is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the objects virtual table. </dd></dl>

</div>
</div>
<a class="anchor" id="ga21cca1ebf690665c9c95474b0873b119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structCInterface.html">CInterface</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vtable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the constructor for interfaces. All implementing classes must call this in their constructor AFTER mapping their virtual table with <a class="el" href="group__Class.html#ga61d2f9a8bea102eb91429b593a1664b4">CVTable( )</a>. This method will setup the interfaces data such that one can back track from the interface reference, param iface, to the object reference, param self, and find the offset into the class' virtual table where the implemented interface methods are located. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>This is a pointer to the object whose class is implementing the interface. </td></tr>
    <tr><td class="paramname">iface</td><td>This is a pointer to the interface instance within the classes declaration. For example, if param self is of type struct A, and struct A implements interface struct I, then this parameter would be a pointer to A::I. </td></tr>
    <tr><td class="paramname">vtable</td><td>This is a pointer to the interfaces virtual table. For example, say, param self is of type struct A, which implements interface struct I, and we are calling this constructor to construct A::I. struct A's vtable, struct A_VT, will contain an instance of struct I's vtable, struct I_VT. This would be a pointer to A_VT::I_VT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac27bc775549c02d69a5854ee4ba24408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CObjectCast_ </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>super_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to cast an object. It must only be used in virtual method definitions. The usage would be this, say we are overriding the destructor, the destructors declaration looks like this void (*)( struct CObject* ). However, we are overriding the method in class struct ArrayList. We know we the input to the method is from an object of that type. This method will cast the input pointer to that type.</p>
<p>The method has a macro wrapper to simply its call signature, CCast( ), which only takes one input, the object refernce.</p>
<p>void* CCast( void* );</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;static void ArrayList_Destructor( struct CObject* self_ )</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    struct ArrayList* self = CCast(self_);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">super_reference</td><td>Reference to cast. </td></tr>
    <tr><td class="paramname">file_name</td><td>Name of the file casting is done in - for debugging. </td></tr>
    <tr><td class="paramname">line_num</td><td>Line number in the file casting is done - for debugging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to casted object. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61d2f9a8bea102eb91429b593a1664b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVTable </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vtable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used within a classes constructor to give the object instance the location of the class' virtual table. This must always be called after constructing the super class and before constructing any interfaces. For example, </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void ArrayList( struct ArrayList* self )</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    CObject(self);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    CVTable(self, ArrayList_VTable_Key( ));</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object which needs a virtual table reference. </td></tr>
    <tr><td class="paramname">vtable</td><td>The pointer to the class' virtual table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jun 8 2017 21:39:17 for CObject by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
